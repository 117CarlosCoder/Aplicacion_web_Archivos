BEGIN;

CREATE DATABASE GamePrueba;

CREATE SCHEMA IF NOT EXISTS inventario;

CREATE SCHEMA IF NOT EXISTS cajero;

CREATE SCHEMA IF NOT EXISTS admin;

CREATE SCHEMA IF NOT EXISTS bodega;

CREATE TABLE IF NOT EXISTS bodega.productos (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    cantidad integer,
    nombre character varying(100),
    precio double precision,
    sucursal character varying(100),
    PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS cajero.detalles_venta (
    id bigserial NOT NULL,
    venta_id bigint NOT NULL,
    producto_id bigint NOT NULL,
    cantidad integer NOT NULL,
    precio_unitario numeric(10, 2) NOT NULL
);

CREATE TABLE IF NOT EXISTS cajero.factura (
    id bigserial NOT NULL,
    venta_id bigint NOT NULL,
    cliente_id bigint,
    fecha_emision date DEFAULT now(),
    monto_total numeric(10, 2) NOT NULL,
    sucursal character varying
);

CREATE TABLE IF NOT EXISTS cajero.ventas (
    id bigserial NOT NULL,
    numero_factura bigserial NOT NULL,
    fecha_emision date DEFAULT now(),
    nit bigint NOT NULL,
    tot_descuentos integer NOT NULL,
    totsin_descuentos integer NOT NULL,
    cajero integer NOT NULL,
    cliente integer NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS inventario.estanteria (
    id bigint NOT NULL GENERATED ALWAYS AS IDENTITY,
    pasillo integer NOT NULL,
    cantidad integer NOT NULL,
    producto_id serial NOT NULL,
    PRIMARY KEY (id)
);



CREATE TABLE IF NOT EXISTS admin.categorias_tarjeta (
    id_tarjeta serial NOT NULL,
    tipo_tarjeta character varying(20) NOT NULL,
    puntos integer NOT NULL,
    gasto_minimo numeric(10, 2) NOT NULL,
    PRIMARY KEY (id_tarjeta),
    UNIQUE (tipo_tarjeta)
);

CREATE TABLE IF NOT EXISTS admin.clientes_tarjeta (
    id_cliente bigint NOT NULL,
    id_tarjeta integer,
    puntos_acumulados integer DEFAULT 0,
    gasto_total numeric(10, 2) DEFAULT 0.00,
    PRIMARY KEY (id_cliente)
);

CREATE TABLE IF NOT EXISTS admin.historial_compras (
    id_compra serial NOT NULL,
    id_cliente bigint,
    monto_gastado numeric(10, 2) NOT NULL,
    fecha_compra date NOT NULL,
    PRIMARY KEY (id_compra)
);

CREATE TABLE IF NOT EXISTS admin.permissions (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    name character varying(255) NOT NULL,
    PRIMARY KEY (id),
    UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS admin.role_permissions (
    admi_role_id bigint NOT NULL,
    admin_permission_id bigint NOT NULL,
    role_id bigint NOT NULL,
    permission_id bigint NOT NULL,
    PRIMARY KEY (admi_role_id, admin_permission_id)
);

CREATE TABLE IF NOT EXISTS admin.roles (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    role_name character varying(255),
    PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS admin.user_roles (
    user_id bigint NOT NULL,
    role_id bigint NOT NULL,
    PRIMARY KEY (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS admin.usuarios (
    account_no_expired boolean,
    account_no_locked boolean,
    credential_no_expired boolean,
    email character varying(255),
    is_enabled boolean,
    name character varying(255),
    nit numeric(38, 0),
    password character varying(255),
    sucursal character varying(255),
    username character varying(255),
    update boolean NOT NULL DEFAULT false,
    id bigserial NOT NULL,
    cajero integer DEFAULT 0,
    PRIMARY KEY (id),
    UNIQUE (email),
    UNIQUE (username),
    UNIQUE (nit)
);

ALTER TABLE IF EXISTS cajero.detalles_venta
    ADD CONSTRAINT fk_detalles_venta_venta_id FOREIGN KEY (venta_id)
    REFERENCES cajero.ventas (id);

ALTER TABLE IF EXISTS cajero.factura
    ADD CONSTRAINT fk_factura_venta_id FOREIGN KEY (venta_id)
    REFERENCES cajero.ventas (id);

ALTER TABLE IF EXISTS admin.historial_compras
    ADD CONSTRAINT historial_compras_id_cliente_fkey FOREIGN KEY (id_cliente)
    REFERENCES admin.clientes_tarjeta (id_cliente);

ALTER TABLE IF EXISTS admin.role_permissions
    ADD CONSTRAINT fk_permission FOREIGN KEY (permission_id)
    REFERENCES admin.permissions (id);

ALTER TABLE IF EXISTS admin.role_permissions
    ADD CONSTRAINT fk_admin_permission FOREIGN KEY (admin_permission_id)
    REFERENCES admin.permissions (id);

ALTER TABLE IF EXISTS admin.role_permissions
    ADD CONSTRAINT fk_role FOREIGN KEY (role_id)
    REFERENCES admin.roles (id);

ALTER TABLE IF EXISTS admin.role_permissions
    ADD CONSTRAINT fk_admi_role FOREIGN KEY (admi_role_id)
    REFERENCES admin.roles (id);

ALTER TABLE IF EXISTS admin.user_roles
    ADD CONSTRAINT fk_user FOREIGN KEY (user_id)
    REFERENCES admin.usuarios (id);

ALTER TABLE IF EXISTS admin.user_roles
    ADD CONSTRAINT fk_role_user FOREIGN KEY (role_id)
    REFERENCES admin.roles (id);


    CREATE PROCEDURE productos_estanteria(
        IN n_id BIGINT, 
        IN n_pasillo INTEGER, 
        IN n_cantidad INTEGER, 
        IN id_producto BIGINT
    )
    LANGUAGE plpgsql
    AS
    $$
    DECLARE
        estanteria_id BIGINT;
        producto_cantidad INT;
    BEGIN
        -- Verificar si el usuario tiene el rol 'INVENTORY'
        IF EXISTS (
            SELECT 1
            FROM admin.usuarios u
            JOIN admin.user_roles ur ON u.id = ur.user_id
            JOIN admin.roles r ON ur.role_id = r.id
            WHERE u.id = n_id AND r.role_name = 'INVENTORY'
        ) THEN
            -- Consultar cantidad del producto en la bodega
            SELECT cantidad INTO producto_cantidad
            FROM bodega.productos
            WHERE id = id_producto;

            IF producto_cantidad IS NULL THEN
                RAISE NOTICE 'Producto con id % no encontrado en la bodega.', id_producto;
                RETURN;
            ELSIF producto_cantidad < n_cantidad THEN
                RAISE NOTICE 'No hay suficiente cantidad del producto con id % en la bodega.', id_producto;
                RETURN;
            END IF;


            INSERT INTO inventario.estanteria (pasillo, cantidad, producto_id)
            VALUES(n_pasillo, n_cantidad, id_producto)
            RETURNING id INTO estanteria_id;

            RAISE NOTICE 'Producto agregado a estantería con id %', estanteria_id;


            UPDATE bodega.productos
            SET cantidad = cantidad - n_cantidad
            WHERE id = id_producto;

            IF NOT FOUND THEN
                RAISE NOTICE 'Producto con id % no encontrado en la bodega.', id_producto;
            ELSE
                RAISE NOTICE 'Cantidad del producto con id % actualizada en la bodega.', id_producto;
            END IF;
        ELSE
            RAISE NOTICE 'El usuario no tiene el rol INVENTORY o no existe.';
        END IF;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Ocurrió un error: %', SQLERRM;
    END;
    $$;


    CREATE FUNCTION listar_productos_estanteria(p_sucursal_producto CHARACTER VARYING)
    RETURNS TABLE(id_producto BIGINT, nombre_producto CHARACTER VARYING, pasillo INTEGER, cantidad_producto INTEGER, sucursal_producto CHARACTER VARYING, precio_producto DOUBLE PRECISION)
    LANGUAGE plpgsql
    AS
    $$
    BEGIN

        IF p_sucursal_producto IS NULL THEN
            RAISE EXCEPTION 'La sucursal debe ser especificada';
        END IF;


        RETURN QUERY
        SELECT p.id, p.nombre, e.pasillo, e.cantidad, p.sucursal, p.precio
        FROM bodega.productos p
        JOIN inventario.estanteria e ON p.id = e.producto_id
        WHERE p.sucursal = p_sucursal_producto;
    END;
    $$;


    CREATE FUNCTION listar_productos(n_sucursal CHARACTER VARYING, n_producto CHARACTER VARYING DEFAULT '%'::CHARACTER VARYING)
    RETURNS TABLE(id BIGINT, nombre CHARACTER VARYING, cantidad INTEGER, sucursal CHARACTER VARYING, precio DOUBLE PRECISION)
    LANGUAGE plpgsql
    AS
    $$
    BEGIN
        IF n_sucursal IS NULL THEN
            RAISE EXCEPTION 'La sucursal debe ser especificada';
        END IF;

        RETURN QUERY
        SELECT p.id, p.nombre, p.cantidad, p.sucursal, p.precio
        FROM bodega.productos p
        WHERE p.sucursal = n_sucursal 
          AND p.cantidad > 0
          AND (n_producto = '' OR p.nombre LIKE n_producto || '%');
    END;
    $$;

    CREATE FUNCTION buscar_usuario_nit(p_nit_pattern CHARACTER VARYING, p_sucursal_pattern CHARACTER VARYING)
    RETURNS TABLE(id BIGINT, name CHARACTER VARYING, username CHARACTER VARYING, email CHARACTER VARYING, sucursal CHARACTER VARYING, nit BIGINT)
    LANGUAGE plpgsql
    AS
    $$
    BEGIN
        RETURN QUERY
        SELECT 
            u.id AS id,
            u.name::CHARACTER VARYING AS name,
            u.username::CHARACTER VARYING AS username,
            u.email::CHARACTER VARYING AS email,
            u.sucursal::CHARACTER VARYING AS sucursal,
            u.nit::BIGINT AS nit
        FROM 
            admin.usuarios u
        INNER JOIN 
            admin.user_roles ur ON u.id = ur.user_id
        INNER JOIN 
            admin.roles r ON ur.role_id = r.id
        WHERE 
            r.role_name = 'CLIENT'
            AND u.nit::CHARACTER VARYING LIKE p_nit_pattern || '%'
            AND u.sucursal::CHARACTER VARYING LIKE p_sucursal_pattern || '%';
    END;
    $$;



    CREATE PROCEDURE actualizar_usuario(
        IN n_id BIGINT, 
        IN n_name CHARACTER VARYING, 
        IN n_email CHARACTER VARYING, 
        IN n_nit BIGINT, 
        IN n_username CHARACTER VARYING
    )
    LANGUAGE plpgsql
    AS $$
    DECLARE
        usuario_id BIGINT;
        role_count BIGINT;
        user_update_status BOOLEAN;
    BEGIN
        -- Verificar si el usuario tiene el rol CLIENT y su estado de actualización
        SELECT COUNT(*), u.update
        INTO role_count, user_update_status
        FROM admin.user_roles ur
        JOIN admin.roles r ON ur.role_id = r.id
        JOIN admin.usuarios u ON ur.user_id = u.id
        WHERE ur.user_id = n_id AND r.role_name = 'CLIENT'
        GROUP BY u.update;

        IF role_count > 0 THEN
            IF user_update_status THEN
                -- Actualizar los datos del usuario
                UPDATE admin.usuarios
                SET name = n_name,
                    email = n_email,
                    nit = n_nit,
                    username = n_username
                WHERE id = n_id
                RETURNING id INTO usuario_id;

                -- Restablecer el campo update a false
                UPDATE admin.usuarios
                SET update = false
                WHERE id = n_id;

                -- Notificar el ID del usuario actualizado
                RAISE NOTICE 'Usuario actualizado con ID: %', usuario_id;
            ELSE
                RAISE NOTICE 'El usuario no puede ser actualizado porque update es false.';
            END IF;
        ELSE
            RAISE NOTICE 'El usuario no tiene el rol CLIENT o no existe.';
        END IF;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Ocurrió un error: %', SQLERRM;
    END;
    $$;
    ALTER PROCEDURE actualizar_usuario(BIGINT, VARCHAR, VARCHAR, BIGINT, VARCHAR) OWNER TO postgres;


    CREATE FUNCTION listar_productos(
        n_sucursal CHARACTER VARYING, 
        n_producto CHARACTER VARYING
    )
    RETURNS TABLE(id BIGINT, nombre CHARACTER VARYING, cantidad INTEGER, sucursal CHARACTER VARYING, precio DOUBLE PRECISION)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        SELECT p.id, p.nombre, p.cantidad, p.sucursal, p.precio
        FROM bodega.productos p
        WHERE p.sucursal = n_sucursal 
          AND p.cantidad > 0
          AND (n_producto = '' OR p.nombre LIKE n_producto || '%');
    END;
    $$;
    ALTER FUNCTION listar_productos(VARCHAR, VARCHAR) OWNER TO postgres;

    CREATE FUNCTION buscar_usuario_nit(
        p_nit_pattern CHARACTER VARYING, 
        p_sucursal_pattern CHARACTER VARYING
    )
    RETURNS TABLE(id BIGINT, name CHARACTER VARYING, username CHARACTER VARYING, email CHARACTER VARYING, sucursal CHARACTER VARYING, nit BIGINT)
    LANGUAGE plpgsql
    AS $$
    BEGIN
        RETURN QUERY
        SELECT 
            u.id AS id,
            u.name::CHARACTER VARYING AS name,
            u.username::CHARACTER VARYING AS username,
            u.email::CHARACTER VARYING AS email,
            u.sucursal::CHARACTER VARYING AS sucursal,
            u.nit::BIGINT AS nit
        FROM 
            admin.usuarios u
        INNER JOIN 
            admin.user_roles ur ON u.id = ur.user_id
        INNER JOIN 
            admin.roles r ON ur.role_id = r.id
        WHERE 
            r.role_name = 'CLIENT'
            AND u.nit::CHARACTER VARYING LIKE p_nit_pattern || '%'
            AND u.sucursal::CHARACTER VARYING LIKE p_sucursal_pattern || '%';
    END;
    $$;
    ALTER FUNCTION buscar_usuario_nit(VARCHAR, VARCHAR) OWNER TO postgres;


    CREATE FUNCTION generar_venta(
        p_nit BIGINT, 
        p_tot_descuentos DOUBLE PRECISION, 
        p_totsin_descuentos DOUBLE PRECISION, 
        p_cajero INTEGER, 
        p_cliente INTEGER, 
        p_productos JSONB, 
        p_sucursal CHARACTER VARYING
    )
    RETURNS TEXT
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_venta_id BIGINT;
        v_total NUMERIC(10, 2);
        product JSONB;
        v_producto_id BIGINT;
        cantidad_pedido INT;
        precio_unitario NUMERIC(10, 2);
        cantidad_actual INT;
    BEGIN
        -- Inserta la venta en la tabla ventas
        INSERT INTO cajero.ventas (nit, tot_descuentos, totsin_descuentos, cajero, cliente)
        VALUES (p_nit, p_tot_descuentos, p_totsin_descuentos, p_cajero, p_cliente)
        RETURNING id INTO v_venta_id;

        -- Itera sobre cada producto en el JSON
        FOR product IN SELECT * FROM jsonb_array_elements(p_productos) LOOP
            -- Verifica que los datos del producto no falten
            IF product->>'producto_id' IS NULL OR product->>'cantidad' IS NULL OR product->>'precio_unitario' IS NULL THEN
                RAISE EXCEPTION 'Datos de producto faltantes o incorrectos: %', product;
            END IF;

            v_producto_id := (product->>'producto_id')::BIGINT;
            cantidad_pedido := (product->>'cantidad')::INT;
            precio_unitario := (product->>'precio_unitario')::NUMERIC(10, 2);

            -- Verifica que la cantidad pedida sea mayor que cero
            IF cantidad_pedido <= 0 THEN
                RAISE EXCEPTION 'La cantidad del producto con ID % debe ser mayor que 0', v_producto_id;
            END IF;

            -- Obtiene la cantidad disponible del producto en la estantería
            SELECT cantidad INTO cantidad_actual FROM inventario.estanteria WHERE producto_id = v_producto_id FOR UPDATE;

            -- Verifica que el producto exista en el inventario
            IF cantidad_actual IS NULL THEN
                RAISE EXCEPTION 'El producto con ID % no existe en el inventario', v_producto_id;
            END IF;

            -- Verifica que haya suficiente stock
            IF cantidad_actual < cantidad_pedido THEN
                RAISE EXCEPTION 'La cantidad pedida para el producto con ID % excede la cantidad en stock. Stock actual: %, Cantidad pedida: %', v_producto_id, cantidad_actual, cantidad_pedido;
            END IF;

            -- Actualiza la cantidad del producto en la estantería
            UPDATE inventario.estanteria SET cantidad = cantidad_actual - cantidad_pedido WHERE producto_id = v_producto_id;

            -- Inserta en detalles de la venta
            INSERT INTO cajero.detalles_venta (venta_id, producto_id, cantidad, precio_unitario)
            VALUES (v_venta_id, v_producto_id, cantidad_pedido, precio_unitario);
        END LOOP;

        -- Calcula el total de la venta
        SELECT SUM((p->>'cantidad')::INT * (p->>'precio_unitario')::NUMERIC(10, 2))
        INTO v_total
        FROM jsonb_array_elements(p_productos) AS p;

        -- Inserta la factura
        INSERT INTO cajero.factura (venta_id, cliente_id, monto_total, sucursal)
        VALUES (v_venta_id, p_cliente, v_total, p_sucursal);

        RETURN 'Venta realizada con éxito, ID de venta: ' || v_venta_id;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'Error en la transacción: %', SQLERRM;
    END;
    $$;
    ALTER FUNCTION generar_venta(BIGINT, DOUBLE PRECISION, DOUBLE PRECISION, INTEGER, INTEGER, JSONB, VARCHAR) OWNER TO postgres;


    CREATE PROCEDURE registrar_cliente(
        IN p_name CHARACTER VARYING, 
        IN p_username CHARACTER VARYING, 
        IN p_password CHARACTER VARYING, 
        IN p_email CHARACTER VARYING, 
        IN p_nit BIGINT, 
        IN p_sucursal CHARACTER VARYING
    )
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_user_id BIGINT;
        v_role_id BIGINT;
    BEGIN
        INSERT INTO admin.usuarios (
            name, username, email, password, nit, sucursal, account_no_expired, account_no_locked, credential_no_expired, is_enabled, update
        ) VALUES (
            p_name, p_username, p_email, p_password, p_nit, p_sucursal, TRUE, TRUE, TRUE, TRUE, FALSE
        )
        RETURNING id INTO v_user_id;

        SELECT id INTO v_role_id
        FROM admin.roles
        WHERE role_name = 'CLIENT';

        INSERT INTO admin.user_roles (user_id, role_id)
        VALUES (v_user_id, v_role_id);

    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Ocurrió un error: %', SQLERRM;
            RETURN;
    END;
    $$;
    ALTER PROCEDURE


END;
